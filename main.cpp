#include <iostream>
#include <fstream>
#include <uf.h>
#include "hashing.h"
#include "vertice.h"
#include "lattice.h"
#include "bst.h"
#include <math.h>
#include <bitset>
#include <queue>

int main(){
//    long int p = 3;
//    std::cout<<GOLDEN_RATIO<<std::endl;
//    double doubleValue;
//    doubleValue = GOLDEN_RATIO;
//    unsigned long long bits = *reinterpret_cast<unsigned long long*>(&doubleValue);
//    int x[3] = {1, 2, 3};
//    int *y = x;
//    for(int i= 0; i<3; i++){
//        int z[3];
//        z[i] = y[i];
//        for(int j=0; j<3; j++){
//            std::cout<<z[j]<<std::endl;
//        }
//    }
//    unsigned long int bits = 0xa0aa;
//    std::cout<<std::bitset<32>(bits)<<std::endl;
//    std::cout<<std::bitset<32>(bits >> 5)<<std::endl;
//    std::cout<<std::bitset<32>(bits >> 5 & 1)<<std::endl;
//    int j = 1072;
//    int l[3] = {1, 2, 3};
//    name::L = l;
//    name k = name(l);
//    name t = name(j);
//    for(int i=0; i<3; i++){
//        std::cout<<"k: "<<k.L[i]<<std::endl;
//        std::cout<<"t: "<<t.L[i]<<std::endl;
//    }
//    Hashing hash = Hashing(1000);
//    hash.test();
//    int N, p, q;
//    std::ifstream file;
//    file.open("/home/marcio/projects/Algoritmos/links.txt");
//    file >> N;
//    UF uf = UF(N);
//    while(file >> p >> q){
//        uf.f_union(p,q);
//    }
//    uf.printComponents();
//    unsigned long long int malha[5] = {100, 100, 100, 100, 100};
//    unsigned long long int seed[5] = {50, 50, 50, 50, 50};
//    Lattice L = Lattice();
////    delete(&L);
//    Lattice::setL(malha);
//    Lattice::setD(sizeof(malha)/sizeof(malha[0]));
////    Hashing h = Hashing(16);
////    Vertice v1 = Vertice(x1, 0);
////    Vertice v2 = Vertice(x2, 0);
//    BST bst = BST();
//    std::cout<<sizeof(malha)/sizeof(malha[0])<<std::endl;
//    unsigned long
//    std::cout<<h.insert(&v2)<<std::endl;
//    std::cout<<bst.insert(&v1)<<std::endl;
//    std::cout<<bst.insert(&v2)<<std::endl;
//    std::cout<<v1.getN()<<std::endl;
//    std::cout<<v2.getN()<<std::endl;
//    std::cout<<h.search(&v1)<<std::endl;
//    std::cout<<h.search(&v2)<<std::endl;
//    std::cout<<bst.search(v1.getN())->getN()<<std::endl;
//    std::cout<<bst.search(v2.getN())->getN()<<std::endl;
//    for(int i =0; i < Lattice::getD(); i++){
//        std::cout<<bst.search(v1.getN())->x[i]<<std::endl;
//    }
    return 0;
}
